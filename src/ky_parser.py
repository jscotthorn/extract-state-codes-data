
"""
    - This file accepts html generated by the OSX textutil app from raw title .rtf files of the KRS
    - The start_parse method is called by parser base
    - This parser is only designed to work on title files, not constitution, AG Opinion, New Section, or other .rtf files included in the Public.Resource.Org export.
"""

from bs4 import BeautifulSoup, Doctype
import re
from datetime import datetime
from parser_base import ParserBase
from enum import Enum
import csv

# Define different pieces of the document we might be in, which is tracked via the supersection variable.
Supersection = Enum('Supersection', [
    'INDEX',
    'CHAPTER_START',
    'SECTION_START',
    'STATUTE_START',
    'STATUTE_BODY',
    'SECTION_HISTORY',
    'ANNOTATION_INDEX', 
    'ANNOTATIONS', 
    'ATTORNEY_GENERAL', 
    'RESEARCH'
])
research_categories = [
    'Cross-References.',
    'ALR',
    'Kentucky Law Journal.',
    'Treatises',
    'Northern Kentucky Law Review.',
    'Kentucky Bench & Bar.',
]

# Known categories for references


class KYParser(ParserBase):
    def __init__(self, input_file_name):
        super().__init__()
        self.file_name = input_file_name
        self.supersection = Supersection.INDEX
        # As lines are parsed, store active values in these variables for logging once all lines in the statute/citation have been parsed
        self.current_title = None
        self.current_chapter = None
        self.cnum = None
        self.ctitle = None
        self.current_section = None
        self.current_statute = None
        self.snum = None
        self.stitle = None
        self.ccat = None
        self.statute_body = '' 
        self.history = ''
        # Lists of statutes and citations are kept until the end and then dumped to csv.
        self.statutes = []
        self.citations = []
        self.start_parse()

    # Log a complete statute to the statutes list.
    def logStatute(self):
        self.statutes.append({
            "Chapter Number": self.cnum,
            "Statute Number": self.snum,
            "Chapter Title": self.ctitle,
            "Section": self.current_section,
            "Statute Title": self.stitle,
            "Statute Body": self.statute_body,
            "History": self.history,
        })
        self.snum = None
        self.stitle = None
        self.statute_body = '' 
        self.history = ''

    # Log a complete citation to the citations list.
    def logCitation(self, type, ctext):
        self.citations.append({
            "Statute Number": self.snum,
            "Type": type,
            "Category": self.ccat,
            "Text": ctext,
        })
        
    # Function to clean a citation category
    def clean_ccat(self, c):
        # Remove leading number, dash, and whitespace
        cleaned = re.sub(r'[-\d]+[\W\sâ€”]+', '', c)
        # Remove trailing period
        cleaned = cleaned.rstrip('.')
        return cleaned.strip()

    # Function to write a list of dictionaries to a CSV file
    def write_to_csv(self, data, filename):
        # Open the file in write mode
        with open(filename, 'w', newline='') as file:
            # Create a CSV writer
            writer = csv.DictWriter(file, fieldnames=data[0].keys())
            # Write the header
            writer.writeheader()
            # Write the data
            for row in data:
                writer.writerow(row)

    def start_parse(self):
        with open(f'../transforms/ky/ocky/r{self.release_number}/raw/{self.file_name}', "r") as file:
            data = BeautifulSoup(file, "html.parser")
            p_tags = data.find_all('p', {"class" : ["p1","p2","p3","p4","p5","p6","p7"]})
            for tag in p_tags: 
                class_name = tag['class'][0]
                text = tag.text.strip()
                if class_name == 'p1':
                    self.current_title = text
                elif class_name == 'p3':
                    if (self.snum is not None):
                        self.logStatute()
                    if 'CHAPTER' in text:
                        self.current_chapter, self.current_statute = text, None
                        supersection = Supersection.CHAPTER_START
                        match = re.match(r'S?U?B?CHAPTER (\d+(?:\w)?)\.? (.+)', text)
                        if match:
                            # Extract the chapter number and title
                            self.cnum = match.group(1)
                            self.ctitle = match.group(2)
                        else:
                            raise ValueError('Could not parse chapter number and text from ' + text);
                    else:
                        self.current_section = text
                        self.supersection = Supersection.SECTION_START
                elif class_name == 'p4':
                    if (self.snum is not None):
                        self.logStatute()
                    self.current_statute = text
                    # Parse the number and text out of the full string.
                    match = re.search(r'(\d+[\w\.]*)\.\s*(.*)', text)
                    if match:
                        self.snum = match.group(1)
                        self.stitle = match.group(2)
                    else:
                        raise ValueError('Could not parse statute number and text from ' + text);
                    self.supersection = Supersection.STATUTE_START
                    self.statute_body, history = '', ''
                elif class_name == 'p5':
                    if 'History' in text:
                        self.supersection = Supersection.SECTION_HISTORY
                    elif 'Annotations' in text:
                        self.supersection = Supersection.ANNOTATION_INDEX
                    elif text == 'Text':
                        self.supersection = Supersection.STATUTE_BODY
                    else:
                        print('Unexpected p5: ' + str(self.supersection) + ' ' + text)
                elif class_name == 'p6':
                    if self.supersection in [Supersection.STATUTE_START, Supersection.STATUTE_BODY]:
                        tab_count = len(tag.find_all('span', class_=['Apple-tab-span']))
                        self.statute_body = self.statute_body + ('\n' if self.statute_body != '' else '') + ('\t' * tab_count) + text
                        self.supersection = Supersection.STATUTE_BODY
                    elif self.supersection == Supersection.SECTION_HISTORY:
                        history = re.sub(r'HISTORY:\s+', '', text)
                elif class_name == 'p7':
                    if ('Opinions of Attorney General.' == text):
                        self.supersection = Supersection.ATTORNEY_GENERAL
                        self.ccat = None
                    elif ('Research References and Practice Aids' in text):
                        self.supersection = Supersection.RESEARCH
                        self.ccat = None
                    elif re.search(r'^\d+\.', text):
                        self.ccat = self.clean_ccat(text)
                        self.supersection = Supersection.ANNOTATIONS
                    elif re.match(r'Cited( in)?:', text):
                        self.ccat = 'Cited'
                        self.supersection = Supersection.ANNOTATIONS
                    elif 'NOTES TO UNPUBLISHED DECISIONS' in text:
                        self.ccat = 'Unpublished Decisions'
                    elif text in research_categories:
                        self.supersection = Supersection.RESEARCH
                        self.ccat = self.clean_ccat(text)
                    # Attempt to catch other one-off groupings that end in colons
                    elif re.match(r':\Z', text):
                        self.ccat = self.clean_ccat(text)
                    elif self.supersection == Supersection.ATTORNEY_GENERAL:
                        self.logCitation('Attorney General Opinion', text)
                    elif self.supersection == Supersection.RESEARCH:
                        self.logCitation('Research References and Practice Aids', text)
                    elif self.supersection == Supersection.ANNOTATIONS:
                        self.logCitation('Annotation', text)

        # Write statutes to a CSV file
        if (len(self.statutes) > 0):
            self.write_to_csv(self.statutes, f'../transforms/ky/ocky/r{self.release_number}/{self.file_name.replace(".html", ".statutes.csv")}')
        else:
            print ('No statutes found in ' + self.file_name);

        # Write citations to a CSV file
        if (len(self.citations) > 0):
            self.write_to_csv(self.citations, f'../transforms/ky/ocky/r{self.release_number}/{self.file_name.replace(".html", ".citations.csv")}')
        else:
            print ('No citations found in ' + self.file_name);


